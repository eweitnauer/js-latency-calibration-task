<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8">

<title>JS Latency Estimation</title>
<meta name="author" content="Graspable, Inc.">

<style>
div#container {
	margin-top: 100px;
	width: 100%;
}
div#track {
	max-width: 400px;
	width: 75%;
	margin: auto;
	border-style: solid;
	border-color: black;
	box-sizing: border-box;
	/*border-radius: 50%;*/
}
div.pacer {
	position: absolute;
	background-color: skyblue;
	border-radius: 50%;
}
</style>
</head>

<body>

<div id="container">
	<div id="track"></div>
</div>

<script>

function px(str) { return str + 'px'; }

var container = document.querySelector('#container');

var track = document.querySelector('#track')
  , t_dims = track.getBoundingClientRect();
t_dims.height = t_dims.width;

var settings = { 'border-width': Math.max(t_dims.width/10, 15)
               , 'pacer-scale-factor': 1 };
var pacer_size = settings['border-width'] * settings['pacer-scale-factor'];
var pacer_r = -pacer_size/2;

track.style.height = px(t_dims.width);
track.style['border-width'] = px(settings['border-width']);

var radius = t_dims.width/2
  , center = [t_dims.left + radius, t_dims.top + radius];
var rotations_per_second = 0.25;

// Remove the "border-radius" styling from the #track and .pacer selectors and
// call `coordinateDemo` to show pacers on all corners, sides, and center of the
// track div.
coordinateDemo();

// Add the "border-radius" styling to the #track and .pacer selectors and call
// `coordinateDemo2` to show pacers on the circle that have been positioned with
// angles.
// coordinateDemo2();

// Use these lines to animate a pacer moving around the track.
var pacer = createPacer();
// window.requestAnimationFrame(step);

function setPosOfPacer(pacer, radians) {
	var pos = getPositionOnTrack(radians, settings['border-width']);
	pacer.style.left = px(pos[0]);
	pacer.style.top = px(pos[1]);
}

function step(timestamp) {
	var seconds_elapsed = timestamp/1000;
	theta = 2*Math.PI*rotations_per_second*seconds_elapsed;
	setPosOfPacer(pacer, theta);
	window.requestAnimationFrame(step);
}

function getPositionOnTrack(radians) {
	var pos = getRadialPos(center, radius, radians);
	return [ pos[0] + pacer_r
	       , pos[1] + pacer_r ];
}
function getRadialPos(center, radius, radians) {
	return [ center[0] + (radius-settings['border-width']/2)*Math.cos(radians)
	       , center[1] + (radius-settings['border-width']/2)*Math.sin(radians) ];
}

function createPacer(pos) {
	var pacer = document.createElement('div');
	pacer.className = 'pacer';
	pacer.style.width = px(pacer_size);
	pacer.style.height = px(pacer_size);
	if (pos) {
		pacer.style.left = px(pos[0]);
		pacer.style.top = px(pos[1]);
	}
	document.body.appendChild(pacer);
	return pacer;
}

function coordinateDemo() {
	// corners
	createPacer([t_dims.left+pacer_r, t_dims.top+pacer_r]); // top-left
	createPacer([t_dims.left+t_dims.width-pacer_size-pacer_r, t_dims.top+pacer_r]); // top-right
	createPacer([t_dims.left+pacer_r, t_dims.top+t_dims.width-pacer_size-pacer_r]); // bottom-left
	createPacer([t_dims.left+t_dims.width-pacer_size-pacer_r, t_dims.top+t_dims.width-pacer_size-pacer_r]); // bottom-right

	// sides
	createPacer([t_dims.left+t_dims.width/2-pacer_size/2, t_dims.top+pacer_r]); // top
	createPacer([t_dims.left+t_dims.width-pacer_size-pacer_r, t_dims.top+t_dims.width/2-pacer_size/2]); // right
	createPacer([t_dims.left+t_dims.width/2-pacer_size/2, t_dims.top+t_dims.width-pacer_size-pacer_r]); // bottom
	createPacer([t_dims.left+pacer_r, t_dims.top+t_dims.width/2-pacer_size/2]); // left

	// center
	createPacer([t_dims.left+t_dims.width/2-pacer_size/2, t_dims.top+t_dims.width/2-pacer_size/2]);
}

function coordinateDemo2() {
	createPacer(getPositionOnTrack(0));
	createPacer(getPositionOnTrack(Math.PI/2));
	createPacer(getPositionOnTrack(Math.PI));
	createPacer(getPositionOnTrack(3*Math.PI/2));
}
</script>
</body>
</html>
